'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cmdToPromise = exports.isCmd = undefined;

var _Object$freeze5;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = require('./utils');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var isCmdSymbol = Symbol('isCmd');
var dispatchSymbol = Symbol('dispatch');
var getStateSymbol = Symbol('getState');

var cmdTypes = {
  RUN: 'RUN',
  ACTION: 'ACTION',
  //CALLBACK: 'CALLBACK',
  BATCH: 'BATCH',
  MAP: 'MAP',
  NONE: 'NONE',
  SEQUENCE: 'SEQUENCE'
};

var isCmd = exports.isCmd = function isCmd(object) {
  return object ? object[isCmdSymbol] : false;
};

function getMappedCmdArgs() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var dispatch = arguments[1];
  var getState = arguments[2];

  return args.map(function (arg) {
    if (arg === dispatchSymbol) return dispatch;else if (arg === getStateSymbol) return getState;else return arg;
  });
}

function handleRunCmd(cmd, dispatch, getState) {
  var onSuccess = cmd.successActionCreator || function () {},
      onFail = cmd.failActionCreator || function () {};

  try {
    var result = cmd.func.apply(cmd, _toConsumableArray(getMappedCmdArgs(cmd.args, dispatch, getState)));

    if ((0, _utils.isPromiseLike)(result) && !cmd.forceSync) {
      return result.then(onSuccess, onFail).then(function (action) {
        return action ? [action] : [];
      });
    }
    var resultAction = onSuccess(result);
    return resultAction ? Promise.resolve([resultAction]) : null;
  } catch (err) {
    if (!cmd.failActionCreator) {
      throw err; //don't swallow errors if they are not handling them
    }
    var _resultAction = onFail(err);
    return _resultAction ? Promise.resolve([_resultAction]) : null;
  }
}

var cmdToPromise = exports.cmdToPromise = function cmdToPromise(cmd, dispatch, getState) {
  switch (cmd.type) {
    case cmdTypes.RUN:
      return handleRunCmd(cmd, dispatch, getState);

    case cmdTypes.ACTION:
      return Promise.resolve([cmd.actionToDispatch]);

    case cmdTypes.BATCH:
      var batchedPromises = cmd.cmds.map(function (nestedCmd) {
        return cmdToPromise(nestedCmd, dispatch, getState);
      }).filter(function (x) {
        return x;
      });
      if (batchedPromises.length === 0) return null;else if (batchedPromises.length === 1) return batchedPromises[0];else return Promise.all(batchedPromises).then(_utils.flatten);

    case cmdTypes.SEQUENCE:
      var firstCmd = cmd.cmds.length ? cmd.cmds[0] : null;
      if (firstCmd) {
        return new Promise(function (resolve) {
          var firstPromise = cmdToPromise(firstCmd, dispatch, getState);
          if (!firstPromise) firstPromise = Promise.resolve([]);
          firstPromise.then(function (result) {
            var remaining = cmdToPromise(sequence(cmd.cmds.slice(1)), dispatch, getState);
            if (remaining) {
              remaining.then(function (innerResult) {
                resolve(result.concat(innerResult));
              });
            } else resolve(result);
          });
        }).then(_utils.flatten);
      } else return null;

    case cmdTypes.MAP:
      var possiblePromise = cmdToPromise(cmd.nestedCmd, dispatch, getState);
      if (!possiblePromise) return null;
      return possiblePromise.then(function (actions) {
        return actions.map(function (action) {
          return cmd.tagger.apply(cmd, _toConsumableArray(cmd.args).concat([action]));
        });
      });

    /*case cmdTypes.CALLBACK:
      return promisify(cmd.nodeStyleFunction)(...getMappedCmdArgs(cmd.args, dispatch, getState))
        .then(cmd.successActionCreator)
        .catch(cmd.failureActionCreator)
        .then((action) => [action])*/

    case cmdTypes.NONE:
      if (cmd.isEffect) {
        console.warn('Effects.none is deprecated and has been renamed Cmd.none. \n            Effects.none will be removed in the next major version.');
      }
      return null;
  }
};

var run = function run(func) {
  var _extends2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(typeof func === 'function', 'Cmd.run: first argument to Cmd.run must be a function');

    (0, _utils.throwInvariant)((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Cmd.run: second argument to Cmd.run must be an options object');

    (0, _utils.throwInvariant)(!options.successActionCreator || typeof options.successActionCreator === 'function', 'Cmd.run: successActionCreator option must be a function if specified');

    (0, _utils.throwInvariant)(!options.failActionCreator || typeof options.failActionCreator === 'function', 'Cmd.run: failActionCreator option must be a function if specified');

    (0, _utils.throwInvariant)(!options.args || options.args.constructor === Array, 'Cmd.run: args option must be an array if specified');
  }

  return Object.freeze(_extends((_extends2 = {}, _defineProperty(_extends2, isCmdSymbol, true), _defineProperty(_extends2, 'type', cmdTypes.RUN), _defineProperty(_extends2, 'func', func), _extends2), options));
};

var promise = function promise(promiseFactory, successActionCreator, failureActionCreator) {
  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  console.warn('Cmd.promise is deprecated. Please use Cmd.run (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdrunfunc-options)');
  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(typeof promiseFactory === 'function', 'Cmd.promise: first argument to Cmd.promise must be a function that returns a promise');

    (0, _utils.throwInvariant)(typeof successActionCreator === 'function', 'Cmd.promise: second argument to Cmd.promise must be a function that returns an action');

    (0, _utils.throwInvariant)(typeof failureActionCreator === 'function', 'Cmd.promise: third argument to Cmd.promise must be a function that returns an action');
  }

  return run(promiseFactory, {
    successActionCreator: successActionCreator,
    failActionCreator: failureActionCreator,
    args: args
  });
};

var call = function call(resultFactory, actionCreator) {
  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  console.warn('Cmd.call is deprecated. Please use Cmd.run (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdrunfunc-options)');
  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(typeof resultFactory === 'function', 'Cmd.call: first argument to Cmd.call must be a function');

    (0, _utils.throwInvariant)(typeof actionCreator === 'function', 'Cmd.call: second argument to Cmd.call must be a function that returns an action');
  }

  return run(resultFactory, {
    successActionCreator: actionCreator,
    args: args
  });
};

var action = function action(actionToDispatch) {
  var _Object$freeze;

  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)((typeof actionToDispatch === 'undefined' ? 'undefined' : _typeof(actionToDispatch)) === 'object' && actionToDispatch !== null && typeof actionToDispatch.type !== 'undefined', 'Cmd.action: first argument and only argument to Cmd.action must be an action');
  }

  return Object.freeze((_Object$freeze = {}, _defineProperty(_Object$freeze, isCmdSymbol, true), _defineProperty(_Object$freeze, 'type', cmdTypes.ACTION), _defineProperty(_Object$freeze, 'actionToDispatch', actionToDispatch), _Object$freeze));
};

var constant = function constant(actionToDispatch) {
  console.warn('Cmd.constant has been renamed Cmd.action.');
  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)((typeof actionToDispatch === 'undefined' ? 'undefined' : _typeof(actionToDispatch)) === 'object' && actionToDispatch !== null && typeof actionToDispatch.type !== 'undefined', 'Cmd.constant: first argument and only argument to Cmd.constant must be an action');
  }
  return action(actionToDispatch);
};

var arbitrary = function arbitrary(func) {
  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  console.warn('Cmd.arbitrary is deprecated. Please use Cmd.run (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdrunfunc-options)');
  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(typeof func === 'function', 'Cmd.arbitrary: first argument to Cmd.arbitrary must be a function');
  }

  return run(func, { args: args });
};

var batch = function batch(cmds) {
  var _Object$freeze2;

  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.batch: first and only argument to Cmd.batch must be an array of other Cmds');
  }

  return Object.freeze((_Object$freeze2 = {}, _defineProperty(_Object$freeze2, isCmdSymbol, true), _defineProperty(_Object$freeze2, 'type', cmdTypes.BATCH), _defineProperty(_Object$freeze2, 'cmds', cmds), _Object$freeze2));
};

var sequence = function sequence(cmds) {
  var _Object$freeze3;

  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.sequence: first and only argument to Cmd.sequence must be an array of other Cmds');
  }

  return Object.freeze((_Object$freeze3 = {}, _defineProperty(_Object$freeze3, isCmdSymbol, true), _defineProperty(_Object$freeze3, 'type', cmdTypes.SEQUENCE), _defineProperty(_Object$freeze3, 'cmds', cmds), _Object$freeze3));
};

var map = function map(nestedCmd, tagger) {
  for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    args[_key4 - 2] = arguments[_key4];
  }

  var _Object$freeze4;

  if (process.env.NODE_ENV !== 'production') {
    (0, _utils.throwInvariant)(isCmd(nestedCmd), 'Cmd.map: first argument to Cmd.map must be another Cmd');

    (0, _utils.throwInvariant)(typeof tagger === 'function', 'Cmd.map: second argument to Cmd.map must be a function that returns an action');
  }

  return Object.freeze((_Object$freeze4 = {}, _defineProperty(_Object$freeze4, isCmdSymbol, true), _defineProperty(_Object$freeze4, 'type', cmdTypes.MAP), _defineProperty(_Object$freeze4, 'tagger', tagger), _defineProperty(_Object$freeze4, 'nestedCmd', nestedCmd), _defineProperty(_Object$freeze4, 'args', args), _Object$freeze4));
};

/*
const callback = (
  nodeStyleFunction,
  successActionCreator,
  failureActionCreator,
  ...args
) => {
  if (process.env.NODE_ENV !== 'production') {
    throwInvariant(
      typeof nodeStyleFunction === 'function',
      'Cmd.callback: first argument to Cmd.callback must be a function that accepts a callback'
    )

    throwInvariant(
      typeof successActionCreator === 'function',
      'Cmd.callback: second argument to Cmd.callback must be a function that returns an action'
    )

    throwInvariant(
      typeof failureActionCreator === 'function',
      'Cmd.callback: third argument to Cmd.callback must be a function that returns an action'
    )
  }

  return Object.freeze({
    [isCmdSymbol]: true,
    type: cmdTypes.CALLBACK,
    nodeStyleFunction,
    successActionCreator,
    failureActionCreator,
    args,
  })
}
*/

var none = Object.freeze((_Object$freeze5 = {}, _defineProperty(_Object$freeze5, isCmdSymbol, true), _defineProperty(_Object$freeze5, 'type', cmdTypes.NONE), _Object$freeze5));

exports['default'] = {
  run: run,
  action: action,
  promise: promise,
  call: call,
  //callback,
  constant: constant,
  arbitrary: arbitrary,
  batch: batch,
  sequence: sequence,
  map: map,
  none: none,
  dispatch: dispatchSymbol,
  getState: getStateSymbol
};